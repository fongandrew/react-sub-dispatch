/*
  HOC for creating a React component that automatically updates upon some set
  of subscribed data sources. Similar in concept to something react-redux but
  agnostic (and more flexible) about how we get and store state.
*/
import * as React from 'react';
import * as T from './types';

export interface Subscription<Props, State> {
  update: (props: Props) => void;
  unsubscribe: () => void;
  getState: () => State;
}

export interface SubscribeFn<Props, State> {
  (props: Props): Subscription<Props, State>;
}

export interface SubscriptionReq<Props, State> {
  type: SubscribeFn<Props, State>;
  props: Props;
}

export function subscribe<Props, State>(
  type: SubscribeFn<Props, State>,
  props: Props
): SubscriptionReq<Props, State> {
  return { type, props };
}

export type SubscriptionReqMap<SubProps, NextProps> = {
  [K in keyof (
    SubProps | NextProps
  )]: SubscriptionReq<SubProps[K], NextProps[K]>;
};

export interface MapToSubscriptions<
  Services,
  OwnProps,
  PostSubProps
> {
  <SubProps>(services: Services, props: OwnProps): SubscriptionReqMap<
    SubProps,
    PostSubProps
  >;
}

export interface MapDispatch<
  Services,
  ActionsMap,
  OwnProps,
  PostDispatchProps
> {
  (
    dispatch: T.DispatchFn<ActionsMap, any>,
    services: Services,
    props: OwnProps
  ): PostDispatchProps;
}

export interface MergeProps<
  OwnProps,
  PostSubProps,
  PostDispatchProps,
  NextProps
> {
  (p1: OwnProps, )
}

export default function connect<
  Services,
  ActionsMap,
  OwnProps,
  PostSubProps,
  PostDispatchProps,
  NextProps
>(
  mapToSubscriptions: MapToSubscriptions<Services, OwnProps, PostSubProps>,
  mapDispatch: MapDispatch<Services, ActionsMap, OwnProps, PostDispatchProps>,
) {

}


// // Callback function for a subscription
// export type SubCb<T> = (value: T) => void;

// // A subscription generated by props P that calls callback with type T
// // on change. May be updated with new props.
// export interface Subscription<P, T> {

//   // Update the subscription with new props.
//   update(props: P, cb: SubCb<T>): void;

//   // Stop the current subscription
//   unsubscribe(): void;

//   // Last state
//   state: T;
// }

// // Function to create subscription from props. Returns 2-tuple with initial
// // value for subscription.
// export type SubFn<P, T> =
//   (props: P, cb: SubCb<T>) => Subscription<P, T>;

// // Map between input props I to subscribeFns for output props O
// export type SubFnMap<I, O> = {
//   [K in keyof O]: SubFn<I, O[K]>
// };

// // Map between input props I to subscriptions for output props O
// export type SubMap<I, O> = {
//   [K in keyof O]: Subscription<I, O[K]>
// };


// // Base class for HOC, updates when subscription changes
// abstract class SubscriberBase<I, O> extends React.Component<I, O> {

//   // Active subscriptions
//   protected subscriptionMap: SubMap<I, O>;

//   constructor(props: I) {
//     super(props);

//     // Create partial objects and fill in.
//     const state: Partial<O> = {};
//     const subscriptionMap: Partial<SubMap<I, O>> = {};

//     // Subscribe for each key
//     const subscribeFnMap = this.getSubscribeFnMap();
//     Object.keys(subscribeFnMap).forEach((key: keyof O) => {
//       const subscription = subscribeFnMap[key](
//         this.props,
//         this.getCallback(key)
//       );
//       state[key] = subscription.state;
//     });

//     this.state = state as O;
//     this.subscriptionMap = subscriptionMap as SubMap<I, O>;
//   }

//   // HOC fills this in to dictate how subscribeFnWorks
//   protected abstract getSubscribeFnMap(): SubFnMap<I, O>;

//   // Return callback to update a given key
//   private getCallback<K extends keyof O>(key: K) {
//     return ((v: O[K]) => this.setState({ [key]: v } as Pick<O, keyof O>));
//   }

//   // Update subscription on prop change
//   componentWillReceiveProps(props: I) {
//     Object.keys(this.subscriptionMap).forEach((key: keyof O) => {
//       this.subscriptionMap[key].update(props, this.getCallback(key))
//     });
//   }

//   // Update only if props or at least one key in state doesn't match
//   shouldComponentUpdate(nextProps: I, nextState: O) {
//     if (this.props !== nextProps) return true;
//     for (let [key, value] of Object.entries(this.state)) {
//       if (nextState[key as keyof O] !== value) return true;
//     }
//     return false;
//   }

//   // Unsubscribe on unmount
//   componentWillUnmount() {
//     Object.keys(this.subscriptionMap).forEach((key: keyof O) => {
//       this.subscriptionMap[key].unsubscribe();
//     });
//   }
// }


// // Alias stateless + other components
// type Component<P> = React.ComponentClass<P>|React.StatelessComponent<P>;

// // HOC
// export default function<I, O1, O2 = O1>(
//   mapSubscribeToProps: SubFnMap<I, O1>,
//   mergeProps?: (stateProps: O1, ownProps: I) => O2
//     // Mix merge props with ownProps
// ) {
//   return function(compCls: Component<O2>) {
//     return class Subscriber extends SubscriberBase<I, O1> {
//       getSubscribeFnMap() {
//         return mapSubscribeToProps;
//       }

//       render() {
//         return React.createElement(compCls, this.getMergedProps());
//       }

//       protected getMergedProps(): O2 {
//         if (mergeProps) {
//           return mergeProps(this.state, this.props);
//         }
//         return this.state as any;
//       }
//     }
//   }
// }
